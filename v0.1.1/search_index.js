var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AdaptiveSparseGrids","category":"page"},{"location":"#AdaptiveSparseGrids.jl","page":"Home","title":"AdaptiveSparseGrids.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository provides an implementation of Linear Interpolation via sparse adaptive grids (using hierarchical linear basis functions) in Julia.  This interpolation method allows one to approximate high dimensional functions to a high degree of accuracy with grid point requirements that grow with a polynomial in the dimension (rather than exponentially).  In practice, this can be used to approximate very high dimensional functions and integrals.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main drawback is that evaluating the interpolant is more costly than with standard interpolation methods, and grows with the dimension of the problem.  In many applications, this cost can be worth paying, since what one loses in more costly interpolation calls, one gains in needing to evaluate the (costly) function that is being approximated at far fewer grid points.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Ma and Zabras (2009) or Brumm and Scheidegger (2017) for more details on the mathematics.","category":"page"},{"location":"#Basic-construction/usage:","page":"Home","title":"Basic construction/usage:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AdaptiveSparseGrids\n\n# Bounds\nlb  = zeros(2)\nub  = ones(2)\n\n# True function to approximate (in practice, this function is costly to\n# evaluate)\nf(x) = 1/(sum(xv^2 for xv in x) + 0.3)\n\n\n# Construct our approximation (this will evaluate f at the needed points, using\n# all available threads)\nfun = AdaptiveSparseGrid(f, lb, ub,\n                         max_depth = 10,    # The maximum depth of basis elements in\n                                            # each dimension\n                         tol = 1e-3)        # Add nodes when\n                                            # min(abs(alpha/f(x)), abs(alpha)) < tol\n\n# Evaluating fun\nx = rand(2)\nfun(x)          # returns value of fun at x\nfun(x, 1)       # returns value of fun[1] at x (if f: R^n -> R^m with m > 1)\n\n# Check how many basis elements we used (dimension of the approximation in\n# function space)\nlength(fun)","category":"page"},{"location":"#Functions-can-return-named-arguments","page":"Home","title":"Functions can return named arguments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The return type of the functions can be named tuples.  You can reference the fieldnames later when accessing the results!","category":"page"},{"location":"","page":"Home","title":"Home","text":"lb  = zeros(2)\nub  = ones(2)\nfun = AdaptiveSparseGrid(lb, ub) do (x, y)\n  (a = 1/( abs(0.5 - x^2 - y^2) + 0.3),\n   b = sin(x) * cos(y))\nend\n\n# Evaluate the function\nx = [0.1, 0.2]\nfun(x)          # returns (a = 1.3328486358686777, b = 0.09784904745121431)\nfun(x, :a)      # returns 1.3328486358686775\nfun(x).a        # returns 1.3328486358686775","category":"page"},{"location":"#Integrating-out-over-a-dimension","page":"Home","title":"Integrating out over a dimension","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can also integrate out a dimension from your approximation","category":"page"},{"location":"","page":"Home","title":"Home","text":"lb  = zeros(2)\nub  = [2pi, pi/4]\nd   = 2\nfun = AdaptiveIntegral((x,y) -> sin(x) * cos(y), lb, ub, d)   # Integrates out the dth\n\n# Evaluate the integral\nfun(pi/2,1)     # returns 0.7070484622124219 (truth is sqrt(2)/2)\nfun(pi/4,1)     # returns 0.4999225237591045 (truth is 0.5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specifying d as collection of dimensions will integrate out over all of them. I haven't yet implemented integrating over anything other than the full domain in each of the specified dimensions, but that wouldn't be too hard to do.","category":"page"},{"location":"#Project-Status","page":"Home","title":"Project Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository is a work in progress.  API changes may come without warning (although I will obviously try not to break things where possible).  The exported API is quite simple, and so my guess is that there won't be many changes, although internals may get shifted around as needed.","category":"page"},{"location":"#AdaptiveSparseGrids","page":"Home","title":"AdaptiveSparseGrids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AdaptiveSparseGrids]","category":"page"},{"location":"#AdaptiveSparseGrids.drive_to_college!-Tuple{Any,Any}","page":"Home","title":"AdaptiveSparseGrids.drive_to_college!","text":"This function inserts the children into the list of nodes for the function approximation\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveSparseGrids.find_parents!-Tuple{AdaptiveSparseGrid,Any,Any}","page":"Home","title":"AdaptiveSparseGrids.find_parents!","text":"Find the parents of the node child and insert them into the list of parents\n\n\n\n\n\n","category":"method"},{"location":"#AdaptiveSparseGrids.refinegrid!-Tuple{Any,AdaptiveSparseGrid}","page":"Home","title":"AdaptiveSparseGrids.refinegrid!","text":"Proceeds in 4 steps     1) Obtain the list of possible child nodes to be created     2) Remove duplicates     3) Evalute the function     4) Insert the points into the grid\n\n\n\n\n\n","category":"method"}]
}
